# 一.JVM专题

## 1.java垃圾回收机制
答案：垃圾回收的意义是：垃圾回收可以有效的防止内存泄漏，有效的使用空闲的内存。
 
## 2.JVM内存布局（每个区放什么）
答案：其中运行时数据区分为程序计数器，虚拟机栈，本地方法栈，堆，方法区（内含运行时常量池）。其中前三个是线程隔离的数据区，堆和方法区是所有线程共享的数据区。还包括不属于运行时数据区的本机直接内存。
该区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 2.1 程序计数器
如果线程正在执行的是Java方法，则计数器用来记录正在执行的虚拟机字节码指令的地址，如果正在执行的是本地方法则为空。

### 2.2 虚拟机栈
虚拟机栈里面存放的是一个个帧栈，每个Java方法在执行的同时会创建一个帧栈用于存放局部变量表（局部变量表所需的内存空间在编译期间完成分配；存放了编译器可知的基本数据类型和对象引用）、操作数栈和动态链接和方法出口等信息。每一个方法从调用直至执行完成的过程，都对应着一个帧栈在java虚拟机栈中入栈和出栈的过程。

该区域可能抛出以下异常：

#### (1). 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
#### (2). 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

### 2.3 本地方法栈
本地方法不是用 Java 实现，对待这些方法需要特别处理。与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。

### 2.4 堆
用来存放实例对象和数组的区域，是垃圾收集的主要区域（“GC 堆”）。垃圾收集器基本都是采用分代手机算法，主要思想是针对不同对象采取不同的垃圾回收算法。虚拟机把Java堆分成以下三块：
#### .新生代
#### .老年代
#### .永久代

## 3.JVM的四种引用及其应用场景
答案：四种引用分别为强引用，软引用，弱引用和虚引用。

### 3.1 强引用
就是平常使用的最多的 new 一个对象时使用到的引用，强引用在程序内存不足（OOM）的时候也不会被回收
#### 可用场景：
使用 new 一个新对象的方式来创建强引用。

### 3.2 软引用
在内存不足的时候会被回收
一个对象时使用到的引用，强引用在程序内存不足（OOM）的时候也不会被回收
#### 可用场景：
创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。PS：图片编辑器，视频编辑器之类的软件可以使用这种思路。

### 3.3 弱引用 
弱引用只要JVM垃圾回收器发现了它，就会把它回收
#### 应用场景：
Java源码中的java.util.WeakHashMap中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。 

### 3.4 虚引用
虚引用的回收机制和弱引用差不多，但是虚引用在回收之前，会被放入引用队列（ReferenceQueue）中。其他引用是被JVM回收之后才被传入ReferenceQueue中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有ReferenceQueue。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
#### 应用场景：
对象销毁前的一些操作，比如说资源释放等。Object.finalize()虽然也可以做这类动作，但是这个方式即不安全又低效。


## 4.GC的可达性分析算法，哪些可作为GC Roots对象？
### 4.1 GC 的可达性分析算法
通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。
### 4.2 GC Roots 一般包含以下内容：
#### .虚拟机栈中的引用的对象
#### .本地方法栈引用的对象
#### .方法区中类静态属性引用的对象
#### .方法区中常量引用的对象

## 5.如何判断对象是不是垃圾？
有两种方法可以判断对象是否存活
### 方法1:引用计数算法
给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数不为 0 的对象仍然存活。

两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
### 方法2:可达性分析算法
通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。详细看第4条。

## 6.堆内部的分区和各自特点

## 7.Minor GC 与 FULL GC 分别什么时候发生？

## 8.对象的创建方法？对象的内存布局？对象的访问定位？

## 9.几种垃圾回收算法的原理和特点，应用的场景，如何优化复制算法的？

## 10. 什么是内存泄露和内存溢出？原因？如何查找？如何避免？

## 11.如何减少gc的次数（java内存管理）

## 12.JVM的常见启动参数？

## 13.常见的内存调试工具？

## 14.数组多大放在JVM老年代？永久代对象如何GC？ 如果不想被GC怎么办？如果想在GC中生存一次怎么办？

## 15.虚拟机的类加载机制？

## 16.双亲委派模型、双亲委派模型有哪些方法？用户如何自定义类加载器，怎么打破双亲委派机制？

## 17.描述Java类加载器的工作原理和组织结构？

## 18.java编译过程

## 19.即时编译器的优化方法

## 20.静态分派与动态分派

## 21.编译阶段对程序作了哪些优化？

## 22.New的对象如何不分配在堆而在栈上

# 二、并发多线程专题

## 1.什么是缓存一致性问题？如何解决？
## 2.简述volatile关键字，如何实现的？哪些应用场景？

## 3.Happens-before原则/as if serial

## 4.ConsurrentHashmap/CopyOnwriteArrayList

## 5.Java的堆和栈有什么不同？

## 6.Java中的活锁、死锁、饥饿有什么区别？

## 7.写一个死锁的程序，如何检测？如何避免？

## 8.什么是线程池？线程池的工作原理和使用线程的好处？

## 9.如何在两个线程间共享数据？

## 10.Collections.syschronizedXXX方法的原理

## 11.ThreadLocal的原理

## 12.如何停止一个线程

## 13.三个线程T1、T2、T3，如何确保它们顺序执行？

## 14.线程的状态？（画图）

## 15.什么是线程调度器？

## 16.用户线程与守护线程有什么区别

## 17.怎么检测一个线程是否拥有锁

## 18.什么是线程的上下文切换？

## 19.Java创建线程后，调用start()和run()的区别？

## 20.Wait()和sleep()的区别？

## 21.Interrupted()方法和isinterrupted方法的区别？

## 22.锁优化？（自旋锁->锁清除->锁粗化->轻量级锁->偏向锁）

## 23.多线程中锁的种类（可重入锁、可中断锁、公平锁、读写锁）

## 24.3条多线程最佳实践

## 25.多线程的优点和缺点

## 26.线程通信？？？

## 27.多线程实现的四种方式？

## 28.Callable与runnable的区别？

## 29.Synchronized与lock的用法？volatile与synchronized 的区别？

## 30.CAS操作？

## 31.wait()\notify()\notifyall()用法(Java中怎样唤醒一个阻塞的线程？)

## 32.写出生产者消费者模式

