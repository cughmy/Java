# 一.JVM专题

## 1.java垃圾回收机制
答案：垃圾回收的意义是：垃圾回收可以有效的防止内存泄漏，有效的使用空闲的内存。
 
## 2.JVM内存布局（每个区放什么）
答案：其中运行时数据区分为程序计数器，虚拟机栈，本地方法栈，堆，方法区（内含运行时常量池）。其中前三个是线程隔离的数据区，堆和方法区是所有线程共享的数据区。还包括不属于运行时数据区的本机直接内存。
该区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 2.1 程序计数器
如果线程正在执行的是Java方法，则计数器用来记录正在执行的虚拟机字节码指令的地址，如果正在执行的是本地方法则为空。

### 2.2 虚拟机栈
虚拟机栈里面存放的是一个个帧栈，每个Java方法在执行的同时会创建一个帧栈用于存放局部变量表（局部变量表所需的内存空间在编译期间完成分配；存放了编译器可知的基本数据类型和对象引用）、操作数栈和动态链接和方法出口等信息。每一个方法从调用直至执行完成的过程，都对应着一个帧栈在java虚拟机栈中入栈和出栈的过程。

该区域可能抛出以下异常：

#### (1). 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
#### (2). 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

### 2.3 本地方法栈
本地方法不是用 Java 实现，对待这些方法需要特别处理。与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。

### 2.4 堆
用来存放实例对象和数组的区域，是垃圾收集的主要区域（“GC 堆”）。垃圾收集器基本都是采用分代手机算法，主要思想是针对不同对象采取不同的垃圾回收算法。虚拟机把Java堆分成以下三块：
#### .新生代
#### .老年代
#### .永久代

## 3.JVM的四种引用及其应用场景
答案：四种引用分别为强引用，软引用，弱引用和虚引用。其中软、弱和虚引用均是在JDK1.2之后才映=引入的。

### 3.1 强引用
就是平常使用的最多的 new 一个对象时使用到的引用，强引用在程序内存不足（OOM）的时候也不会被回收
#### 可用场景：
使用 new 一个新对象的方式来创建强引用。

### 3.2 软引用
在内存不足的时候会被回收
一个对象时使用到的引用，强引用在程序内存不足（OOM）的时候也不会被回收
#### 可用场景：
创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。PS：图片编辑器，视频编辑器之类的软件可以使用这种思路。

### 3.3 弱引用 
弱引用只要JVM垃圾回收器发现了它，就会把它回收。
#### 应用场景：
Java源码中的java.util.WeakHashMap中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。 

### 3.4 虚引用
虚引用的回收机制和弱引用差不多，但是虚引用在回收之前，会被放入引用队列（ReferenceQueue）中。其他引用是被JVM回收之后才被传入ReferenceQueue中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有ReferenceQueue。无法通过一个弱引用来获取一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
#### 应用场景：
对象销毁前的一些操作，比如说资源释放等。Object.finalize()虽然也可以做这类动作，但是这个方式即不安全又低效。


## 4.GC的可达性分析算法，哪些可作为GC Roots对象？
### 4.1 GC 的可达性分析算法
通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。
### 4.2 GC Roots 一般包含以下内容：
#### .虚拟机栈中的引用的对象
#### .本地方法栈引用的对象
#### .方法区中类静态属性引用的对象
#### .方法区中常量引用的对象

## 5.如何判断对象是不是垃圾？
有两种方法可以判断对象是否存活
### 方法1:引用计数算法
给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数不为 0 的对象仍然存活。

两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
### 方法2:可达性分析算法
通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。详细看第4条。

## 6.堆内部的分区和各自特点
堆里面分为新生代和老生代，新生代包含Eden+Survivor区，survivor区里面又分为from和to区，内存回收时，用的是复制（copying）算法，从from复制到to，当经过一次或者多次GC之后，存活下来的对象会被移动到老年区，当JVM内存不够用的时候，会触发Full GC，清理JVM老年区

当新生区满了之后会触发YGC,先把存活的对象放到其中一个Survice区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把Eden 进行完全的清理，然后整理内存。那么下次GC 的时候，就会使用下一个Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为JVM 认为，一般大对象的存活时间一般比较久远。

## 7.Minor GC 与 FULL GC 分别什么时候发生？
新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC

### 7.1 Minor GC 
MGC是新生代Copying算法，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。MinorGC触发条件：
#### (1). 当Eden区满时，触发Minor GC。

### 7.2 FULL GC 
FGC的老年代，采取的Mark-Compact，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。Full GC触发条件：
#### (1）调用System.gc时，系统建议执行Full GC，但是不必然执行。
####（2）老年代空间不足。
####（3）方法区空间不足。
####（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存。

## 8.对象的创建方法？对象的内存布局？对象的访问定位？
一个简单的创建对象语句Clazz instance = new Clazz();包含的主要过程包括了类加载检查、对象分配内存、并发处理、内存空间初始化、对象设置、执行ini方法等。

### 8.1 对象的创建方法：
当JVM遇到一个new指令的时候，首先将去检查这个指令的参数能否在常量池中找到 一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载、解析、初始化过。如果没有，将先进行类加载的过程。
### 8.2 对象内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。
### 8.3 对象的访问定位
创建对象是为了使用它，那么Java程序如何通过栈上的引用来找到堆上的对象？目前两种主流的方式分别是使用句柄和直接指针两种。
#### (1). 使用句柄来访问：堆中划分一块内存作为句柄池，栈中存放的引用就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
#### (2).直接指针：栈中存放引用直接就是对象地址。
以上两种方法各有优缺点：使用句柄的好处就是引用中存储的是稳定的句柄地址，在对象被移动时(GC收集时会经常移动对象)只会改变句柄中实例数据指针，而引用本身不需要变化。指针访问的最大好处就是快，节约了一次指针定位的时间开销。主要的虚拟机Sun HotSpot采用的就是指针访问。
### 8.4 对象的内存布局：
在类加载检查通过后，虚拟机就要为新生对象分配内存，所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。为对象分配内存的两种方式：
#### (1). 指针碰撞：假设Java堆中的对象是绝对规整的，所有用过的放一边，没用过的放另一边，中间有一个指针作为一个分界的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
#### (2). 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和未使用的内存相互相错，这时就没办法用指针碰撞的方式，这时虚拟机就必须维护一个列表，用以记录哪些内存块是可用的，在分配的时候从列表中找出一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。

## 9.几种垃圾回收算法的原理和特点，应用的场景，如何优化复制算法的？
下面是几种常见的垃圾回收算法：
### 9.1 Mark-Sweep (标记-清除)：分为两个阶段，标记和清理阶段
对需要被回收的对象进行标记
标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。
标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发GC。
### 9.2 Copying (复制) 算法，首先将内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把第一块内存上的空间一次清理掉，这样就不容易出现内存碎片的问题，并且运行高效。
但是该算法导致能够使用的内存缩减到原来的一半。而且，<font color=#0099ff>该算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低</font>。（这也是为什么后面提到的新生代采用Copying算法）
### 9.2.1 Copying (复制) 算法的优化：
例如在新生代的垃圾回收中，根据实际需要，不是按照1：1的比例来划分新生代的空间的，而是按照Eden：from Survivor:to Survivor=8:1:1.
### 9.3 Mark-Compact(标记-整理)：为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。
该算法在标记阶段，将需要被被回收的对象进行标记，将存活的对象都移向另一端，然后清理掉端边界以外的所有内存（只留下存活对象）。
### 9.4 Generational Collection（分代收集）算法
<font color=#0099ff>分代收集算法</font>是目前大部分JVM的垃圾收集器采用的算法。
它的核心思想是将堆（Heap）划分为老年代（Tenured Generation）和老年代（Young Generation），老年代的特点是每次垃圾收集时只是少量对象需要被回收。而新生代的特点恰好相反，新生代的特点是每次垃圾回收时都有大量对象需要被回收。那么就可以针对堆的不同代（新生代，老年代）采取不同的最适合的收集算法。
目前大部分垃圾收集器对于新生代都采用Copying算法，因为新生代每次垃圾回收时都要<font color=#0099ff>回收大部分对象</font>,
也就是说需要复制的操作次数较少，该算法效率在新生代也较高。但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（比例8：1：1），每次使用Eden空间和其中的一块Survivor空间A，当进行回收时，将还存活的对象复制到另一块Survivor空间B中，然后清理掉Eden和A空间。在进行了第一次GC之后，使用的便是Eden space和B空间了，下次GC时会将存活对象复制到A空间，如此反复循环。

当对象躲过一次GC的话，其对象年龄便会加1，默认情况下，对象的年龄达到15时，就会移动到老年代中。一般来说，大对象会被直接分配到老年代中，所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组，比如：byte[] data = newbyte[4*1024*1024]。

当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。这些搬运工作都是GC完成的，GC不仅负责在Heap中搬运实例，同时负责回收存储空间。

最后，因为每次回收都只回收少量对象，所以<font color=#0099ff>老年代一般使用的是标记整理算法</font>。
<font color=#0099ff>补充：对永久代的回收主要回收两部分内容：废弃常量和无用的类。</font>
## 10. 什么是内存泄露和内存溢出？原因？如何查找？如何避免？
### 10.1 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
### 10.2 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。memory leak会最终会导致out of memory！
<font color=#0099f0>待补充</font>

## 11.如何减少gc的次数（java内存管理）

## 12.JVM的常见启动参数？

## 13.常见的内存调试工具？

## 14.数组多大放在JVM老年代？永久代对象如何GC？ 如果不想被GC怎么办？如果想在GC中生存一次怎么办？

## 15.虚拟机的类加载机制？

## 16.双亲委派模型、双亲委派模型有哪些方法？用户如何自定义类加载器，怎么打破双亲委派机制？

## 17.描述Java类加载器的工作原理和组织结构？

## 18.java编译过程

## 19.即时编译器的优化方法

## 20.静态分派与动态分派

## 21.编译阶段对程序作了哪些优化？

## 22.New的对象如何不分配在堆而在栈上

# 二、并发多线程专题

## 1.什么是缓存一致性问题？如何解决？
## 2.简述volatile关键字，如何实现的？哪些应用场景？

## 3.Happens-before原则/as if serial

## 4.ConsurrentHashmap/CopyOnwriteArrayList

## 5.Java的堆和栈有什么不同？

## 6.Java中的活锁、死锁、饥饿有什么区别？

## 7.写一个死锁的程序，如何检测？如何避免？

## 8.什么是线程池？线程池的工作原理和使用线程的好处？

## 9.如何在两个线程间共享数据？

## 10.Collections.syschronizedXXX方法的原理

## 11.ThreadLocal的原理

## 12.如何停止一个线程

## 13.三个线程T1、T2、T3，如何确保它们顺序执行？

## 14.线程的状态？（画图）

## 15.什么是线程调度器？

## 16.用户线程与守护线程有什么区别

## 17.怎么检测一个线程是否拥有锁

## 18.什么是线程的上下文切换？

## 19.Java创建线程后，调用start()和run()的区别？

## 20.Wait()和sleep()的区别？

## 21.Interrupted()方法和isinterrupted方法的区别？

## 22.锁优化？（自旋锁->锁清除->锁粗化->轻量级锁->偏向锁）

## 23.多线程中锁的种类（可重入锁、可中断锁、公平锁、读写锁）

## 24.3条多线程最佳实践

## 25.多线程的优点和缺点

## 26.线程通信？？？

## 27.多线程实现的四种方式？

## 28.Callable与runnable的区别？

## 29.Synchronized与lock的用法？volatile与synchronized 的区别？

## 30.CAS操作？

## 31.wait()\notify()\notifyall()用法(Java中怎样唤醒一个阻塞的线程？)

## 32.写出生产者消费者模式

