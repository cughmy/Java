# 一.JVM专题

## 1.java垃圾回收机制
答案：垃圾回收的意义是：垃圾回收可以有效的防止内存泄漏，有效的使用空闲的内存。
 
## 2.JVM内存布局（每个区放什么）
答案：其中运行时数据区分为程序计数器，虚拟机栈，本地方法栈，堆，方法区（内含运行时常量池）。其中前三个是线程隔离的数据区，堆和方法区是所有线程共享的数据区。还包括不属于运行时数据区的本机直接内存。
该区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 2.1 程序计数器
如果线程正在执行的是Java方法，则计数器用来记录正在执行的虚拟机字节码指令的地址，如果正在执行的是本地方法则为空。

### 2.2 虚拟机栈
虚拟机栈里面存放的是一个个帧栈，每个Java方法在执行的同时会创建一个帧栈用于存放局部变量表（局部变量表所需的内存空间在编译期间完成分配；存放了编译器可知的基本数据类型和对象引用）、操作数栈和动态链接和方法出口等信息。每一个方法从调用直至执行完成的过程，都对应着一个帧栈在java虚拟机栈中入栈和出栈的过程。

该区域可能抛出以下异常：

#### (1). 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
#### (2). 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

### 2.3 本地方法栈
本地方法不是用 Java 实现，对待这些方法需要特别处理。与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。

### 2.4 堆
用来存放实例对象和数组的区域，是垃圾收集的主要区域（“GC 堆”）。垃圾收集器基本都是采用分代手机算法，主要思想是针对不同对象采取不同的垃圾回收算法。虚拟机把Java堆分成以下三块：
#### .新生代
#### .老年代
#### .永久代

## 3.JVM的四种引用及其应用场景
答案：四种引用分别为强引用，软引用，弱引用和虚引用。其中软、弱和虚引用均是在JDK1.2之后才映=引入的。

### 3.1 强引用
就是平常使用的最多的 new 一个对象时使用到的引用，强引用在程序内存不足（OOM）的时候也不会被回收
#### 可用场景：
使用 new 一个新对象的方式来创建强引用。

### 3.2 软引用
在内存不足的时候会被回收
一个对象时使用到的引用，强引用在程序内存不足（OOM）的时候也不会被回收
#### 可用场景：
创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。PS：图片编辑器，视频编辑器之类的软件可以使用这种思路。

### 3.3 弱引用 
弱引用只要JVM垃圾回收器发现了它，就会把它回收。
#### 应用场景：
Java源码中的java.util.WeakHashMap中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。 

### 3.4 虚引用
虚引用的回收机制和弱引用差不多，但是虚引用在回收之前，会被放入引用队列（ReferenceQueue）中。其他引用是被JVM回收之后才被传入ReferenceQueue中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有ReferenceQueue。无法通过一个弱引用来获取一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
#### 应用场景：
对象销毁前的一些操作，比如说资源释放等。Object.finalize()虽然也可以做这类动作，但是这个方式即不安全又低效。


## 4.GC的可达性分析算法，哪些可作为GC Roots对象？
### 4.1 GC 的可达性分析算法
通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。
### 4.2 GC Roots 一般包含以下内容：
#### .虚拟机栈中的引用的对象
#### .本地方法栈引用的对象
#### .方法区中类静态属性引用的对象
#### .方法区中常量引用的对象

## 5.如何判断对象是不是垃圾？
有两种方法可以判断对象是否存活
### 方法1:引用计数算法
给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数不为 0 的对象仍然存活。

两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
### 方法2:可达性分析算法
通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。详细看第4条。

## 6.堆内部的分区和各自特点
堆里面分为新生代和老生代，新生代包含Eden+Survivor区，survivor区里面又分为from和to区，内存回收时，用的是复制（copying）算法，从from复制到to，当经过一次或者多次GC之后，存活下来的对象会被移动到老年区，当JVM内存不够用的时候，会触发Full GC，清理JVM老年区

当新生区满了之后会触发YGC,先把存活的对象放到其中一个Survice区，然后进行垃圾清理。因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把Eden 进行完全的清理，然后整理内存。那么下次GC 的时候，就会使用下一个Survive，这样循环使用。如果有特别大的对象，新生代放不下，就会使用老年代的担保，直接放到老年代里面。因为JVM 认为，一般大对象的存活时间一般比较久远。

## 7.Minor GC 与 FULL GC 分别什么时候发生？
新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC

### 7.1 Minor GC 
MGC是新生代Copying算法，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。MinorGC触发条件：
#### (1). 当Eden区满时，触发Minor GC。

### 7.2 FULL GC 
FGC的老年代，采取的Mark-Compact，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。Full GC触发条件：
#### (1）调用System.gc时，系统建议执行Full GC，但是不必然执行。
####（2）老年代空间不足。
####（3）方法区空间不足。
####（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存。

## 8.对象的创建方法？对象的内存布局？对象的访问定位？
一个简单的创建对象语句Clazz instance = new Clazz();包含的主要过程包括了类加载检查、对象分配内存、并发处理、内存空间初始化、对象设置、执行ini方法等。

### 8.1 对象的创建方法：
当JVM遇到一个new指令的时候，首先将去检查这个指令的参数能否在常量池中找到 一个类的符号引用，并且检查这个符号引用所代表的类是否已经被加载、解析、初始化过。如果没有，将先进行类加载的过程。
### 8.2 对象内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。
### 8.3 对象的访问定位
创建对象是为了使用它，那么Java程序如何通过栈上的引用来找到堆上的对象？目前两种主流的方式分别是使用句柄和直接指针两种。
#### (1). 使用句柄来访问：堆中划分一块内存作为句柄池，栈中存放的引用就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
#### (2).直接指针：栈中存放引用直接就是对象地址。
以上两种方法各有优缺点：使用句柄的好处就是引用中存储的是稳定的句柄地址，在对象被移动时(GC收集时会经常移动对象)只会改变句柄中实例数据指针，而引用本身不需要变化。指针访问的最大好处就是快，节约了一次指针定位的时间开销。主要的虚拟机Sun HotSpot采用的就是指针访问。
### 8.4 对象的内存布局：
在类加载检查通过后，虚拟机就要为新生对象分配内存，所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。为对象分配内存的两种方式：
#### (1). 指针碰撞：假设Java堆中的对象是绝对规整的，所有用过的放一边，没用过的放另一边，中间有一个指针作为一个分界的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
#### (2). 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和未使用的内存相互相错，这时就没办法用指针碰撞的方式，这时虚拟机就必须维护一个列表，用以记录哪些内存块是可用的，在分配的时候从列表中找出一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。

## 9.几种垃圾回收算法的原理和特点，应用的场景，如何优化复制算法的？
下面是几种常见的垃圾回收算法：
### 9.1 Mark-Sweep (标记-清除)：分为两个阶段，标记和清理阶段
对需要被回收的对象进行标记
标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。
标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发GC。
### 9.2 Copying (复制) 算法，首先将内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把第一块内存上的空间一次清理掉，这样就不容易出现内存碎片的问题，并且运行高效。
但是该算法导致能够使用的内存缩减到原来的一半。而且，<font color=#0099ff>该算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低</font>。（这也是为什么后面提到的新生代采用Copying算法）
### 9.2.1 Copying (复制) 算法的优化：
例如在新生代的垃圾回收中，根据实际需要，不是按照1：1的比例来划分新生代的空间的，而是按照Eden：from Survivor:to Survivor=8:1:1.
### 9.3 Mark-Compact(标记-整理)：为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。
该算法在标记阶段，将需要被被回收的对象进行标记，将存活的对象都移向另一端，然后清理掉端边界以外的所有内存（只留下存活对象）。
### 9.4 Generational Collection（分代收集）算法
<font color=#0099ff>分代收集算法</font>是目前大部分JVM的垃圾收集器采用的算法。
它的核心思想是将堆（Heap）划分为老年代（Tenured Generation）和老年代（Young Generation），老年代的特点是每次垃圾收集时只是少量对象需要被回收。而新生代的特点恰好相反，新生代的特点是每次垃圾回收时都有大量对象需要被回收。那么就可以针对堆的不同代（新生代，老年代）采取不同的最适合的收集算法。
目前大部分垃圾收集器对于新生代都采用Copying算法，因为新生代每次垃圾回收时都要<font color=#0099ff>回收大部分对象</font>,
也就是说需要复制的操作次数较少，该算法效率在新生代也较高。但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（比例8：1：1），每次使用Eden空间和其中的一块Survivor空间A，当进行回收时，将还存活的对象复制到另一块Survivor空间B中，然后清理掉Eden和A空间。在进行了第一次GC之后，使用的便是Eden space和B空间了，下次GC时会将存活对象复制到A空间，如此反复循环。

当对象躲过一次GC的话，其对象年龄便会加1，默认情况下，对象的年龄达到15时，就会移动到老年代中。一般来说，大对象会被直接分配到老年代中，所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组，比如：byte[] data = newbyte[4*1024*1024]。

当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。这些搬运工作都是GC完成的，GC不仅负责在Heap中搬运实例，同时负责回收存储空间。

最后，因为每次回收都只回收少量对象，所以<font color=#0099ff>老年代一般使用的是标记整理算法</font>。
<font color=#0099ff>补充：对永久代的回收主要回收两部分内容：废弃常量和无用的类。</font>
## 10. 什么是内存泄露和内存溢出？原因？如何查找？如何避免？
### 10.1 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
### 10.2 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。memory leak会最终会导致out of memory！
<font color=#0099f0>待补充</font>


## 11.如何减少gc的次数（java内存管理）
GC会Stop-The-World。会暂停程序的执行，带来延迟的代价。所以在开发中，我们不希望GC的次数过多。
本文将讨论如何在开发中改善各种细节，从而减少GC的次数。

#### (1)对象不用时最好显式置为 Null
一般而言,为 Null 的对象都会被作为垃圾处理,所以将不用的对象显式地设
为 Null,有利于 GC 收集器判定垃圾,从而提高了 GC 的效率。
#### (2)尽量少用 System.gc()
此函数建议 JVM进行主 GC,虽然只是建议而非一定,但很多情况下它会触发
主 GC,从而增加主 GC 的频率,也即增加了间歇性停顿的次数。
#### (3)尽量少用静态变量
静态变量属于全局变量,不会被 GC 回收,它们会一直占用内存。
#### (4)尽量使用 StringBuffer,而不用 String 来累加字符串
由于 String 是固定长的字符串对象,累加 String 对象时,并非在一个 String对象中扩增,而是重新创建新的 String 对象,如 Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的 String 对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。 避免这种情况可以改用 StringBuffer 来累加字符串,因 StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象
#### (5)分散对象创建或删除的时间
集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM 在面临这种情况时,只能进行主 GC,以回收内存或整合内存碎片,从而增加主 GC 的频率。
集中删除对象,道理也是一样的。 它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主 GC 的机会。
####（6） 尽量少用 finalize 函数
因为它会加大 GC 的工作量， 因此尽量少用finalize 方式回收资源。
####（7） 使用软引用类型
如果需要使用经常用到的图片， 可以使用软引用类型， 它可以尽可能将图片保存在内存中， 供程序调用， 而不引起 OutOfMemory。

## 12.JVM的常见启动参数？
-Xms: 设置Java内存的初始大小
-Xmx: 设置jvm内存的最大值
-Xmn: 设置新生代的内存大小
这样老年代的大小就是Xmx-Xmn
-Xss: 设置每个线程的堆栈大小（也就说，在相同大小的无力内存下，减小这个值能生成更多的线程）
-XX: NewRatio:设置新生代与老年代之比，如-XX：NewRatio=4就表示新生代与老年代之比为1：4
-XX: NewSize：设置新生代的初始值
-XX: MaxNewSize：设置新生代的最大值
-XX: MaxPermSize：设置老年代的最大值
-XX: SurvivorRatio=n:设置新生代中Eden区与两个Survivor区的比值。（Eden区主要是用来存放新生的对象，而两个Survivor区则用来存放每次垃圾回收后存活下来的对象）

## 13.常见的内存调试工具？
常用的内存调试工具：jps、jmap、jhat、jstack、jconsole，jstat：
jps:查看虚拟机进程的状况，如进程ID。
jmap: 用于生成堆转储快照文件（某一时刻的）。
jhat：对生成的堆转储快照文件进行分析。
jstack:用来生成线程快照（某一时刻的）。
生成线程快照的主要目的是定位线程长时停顿的原因（如死锁，死循环，等待I/O 等），通过查看各个线程的调用堆栈，就可以知道没有响应的线程在后台做了什么或者等待什么资源。
jstat:虚拟机统计信息监视工具。如显示垃圾收集的情况，内存使用的情况。
jconsole:主要是内存监控和线程监控。
内存监控：可以显示内存的使用情况。线程监控：遇到线程停顿时，可以使用这个功能。

## 14.数组多大放在JVM老年代？永久代对象如何GC？ 如果不想被GC怎么办？如果想在GC中生存一次怎么办？
### 14.1 虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（复习一下：新生代采用复制算法收集内存）。
注意　PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数。
### 14.2 hotspot的方法区存放在永久代中，因此方法区被人们称为永久代。永久代的垃圾回收主要包括类型的卸载和废弃常量池的回收。
待补充
## 15.虚拟机的类加载机制？
类是在运行期间动态加载的。
类的生命周期：
加载，验证，准备，解析，初始化，以及使用和卸载。其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。
### 15.1 类的初始化时机
虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：
#### (1). 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。
#### (2).使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
#### (3).当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
#### (4).当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
#### (5).当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

### 15.2 类加载的过程
包含了加载、验证、准备、解析和初始化这 5 个阶段。
#### (1). 加载
加载是类加载的一个阶段，注意不要混淆。
加载过程完成以下三件事：
通过一个类的全限定名来获取定义此类的二进制字节流。
将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。
在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。
其中二进制字节流可以从以下方式中获取：

##### 获取二进制字节流的具体流程：
从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。
从网络中获取，这种场景最典型的应用是 Applet。
运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。
从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 ...
#### (2). 验证
确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

文件格式验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。
元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。
字节码验证：通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。
符号引用验证：发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。
#### (3). 准备
类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次）
初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。
public static int value = 123;
如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。
public static final int value = 123;
#### (4). 解析
分为静态解析和动态绑定，如果是动态绑定，那么解析操作可能在初始化操作之后。
在类加载的过程中，将常量池的符号引用替换为直接引用的过程。可以在类加载阶段被静态解析的方法有静态方法，私有方法，实例构造方法和父类方法四种方法。

#### (5). 初始化
初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 <clinit>() 方法的过程。
在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。
这里还设计到了<clinit>方法的使用，待补充

## 16.双亲委派模型、双亲委派模型有哪些方法？用户如何自定义类加载器，怎么打破双亲委派机制？
### 16.1 双亲委派模型、双亲委派模型有哪些方法：
双亲委派模型是以启动类加载器（JAVA_HOME\lib目录中的类库）为顶层，
下面依次是扩展类加载器（JAVA_HOME\lib\ext目录中的类库），
应用程序类加载器（负责加载用户类路径（Classpath）上所指定的类库），
和自定义的类加载器这样一个层次结构。

双亲委派模型的工作过程：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传给启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。
### 16.2 用户如何自定义类加载器
只需要继承ClassLoader，并重写（@Override）findClass()方法
### 16.3 怎么打破双亲委派机制
重写loadClass()方法，将需要特殊对待的类自己处理，非处理范围的类调用super方法即可。
例如：Tomcat中的web 容器类加载器也是破坏了双亲委托模式的，自定义的WebApplicationClassLoader除了核心类库外，都是优先加载自己路径下的Class

## 17.描述Java类加载器的工作原理和组织结构？
双亲委派模型的工作原理：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传给启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。

## 18.java编译过程
java代码的编译过程大致可以分为以下3个过程：
#### 1. 解析与填充符号过程
##### (1). 词法、语法分析；标记（Token）
##### (2). 填充符号表
#### 2. 插入式注解处理器的注解处理过程
#### 3. 语义分析与字节码生成过程
##### (1). 标注检查
##### (2). 数据及控制流分析
##### (3). 解语法糖
##### (4). 字节码生成

## 19.即时编译器的优化方法
首先，我们大家都知道，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。
### 19.1 JIT 编译过程
在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。下面我们看看，JIT 的工作过程。
当 JIT 编译启用时（默认是启用的），JVM 读入XXX.class 文件解释后，将其发给 JIT 编译器。JIT 编译器将字节码编译成本机机器代码,加快程序的执行的速度。
### 19.2 被及时编译器编译的“热点代码”有两类
##### .被多次调用的方法。
##### .被多次调用的循环体。
### 19.3 目前主要的热点 判定方式有以下两种：
#### (1). 基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测
#### (2). 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨
HotSpot虚拟机选择第二种策略。

## 20.静态分派与动态分派
### 20.1 静态分派
所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派，静态分派的最典型应用就是多态性中的方法重载。静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。
最常见的静态分派实例就是多态中方法的重载。
### 20.2 动态分派
动态分派与多态性的另一个重要体现——方法覆写有着很紧密的关系。向上转型后调用子类覆写的方法便是一个很好地说明动态分派的例子。这种情况很常见，因此这里不再用示例程序进行分析。很显然，在判断执行父类中的方法还是子类中覆盖的方法时，如果用静态类型来判断，那么无论怎么进行向上转型，都只会调用父类中的方法，但实际情况是，根据对父类实例化的子类的不同，调用的是不同子类中覆写的方法，很明显，这里是要根据变量的实际类型来分派方法的执行版本的。而实际类型的确定需要在程序运行时才能确定下来，这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。
最常见的动态分派实例就是多态中方法的子类对父类方法的重写。

## 21.编译阶段对程序作了哪些优化？
随着动态编译器一起出现的是性能计数器。例如，编译器会插入性能计数器，以统计每个字节码块（对应与某个被调用的方法）的调用次数。在进行相关优化时，编译器会使用收集到的数据来判断某个字节码块有多“热”，这样可以最大程度的降低对当前应用程序的影响。运行时数据监控有助于编译器完成多种代码优化工作，进一步提升代码执行性能。随着收集到的运行时数据越来越多，编译器就可以完成一些额外的、更加复杂的代码优化工作，例如编译出更高质量的目标代码，使用运行效率更高的代码替换原代码，甚至是剔除冗余操作等。例如JiT
还有客户端编译器，服务器端编译器和层次编译器综合客户端编译器和服务器端编译器的恶优点。
待修改。。。
## 22.New的对象如何不分配在堆而在栈上
首先要明确一点，栈上分配可以提升代码性能，降低在多线程情况下的锁使用，但是会受限于其空间的大小。
进行逃逸分析（其是否打开逃逸分析依赖于以下JVM的设置：-XX:+DOescapeAnalysis）之后，
产生的后果是所有的对象都将由栈上分配，而非从JVM内存模型中的堆来分配。
#### 22.1 优势：
##### (1). 消除同步。线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。
##### (2). 矢量替代。逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在CPU寄存器内，这样能大大提高访问速度。
#### 22.2 劣势：
栈上分配受限于栈的空间大小，一般自我迭代类的需求以及大的对象空间需求操作，将导致栈的内存溢出；故只适用于一定范围之内的内存范围请求。


# 二、并发多线程专题

## 1.什么是缓存一致性问题？如何解决？

## 2.简述volatile关键字，如何实现的？哪些应用场景？

## 3.Happens-before原则/as if serial

## 4.ConsurrentHashmap/CopyOnwriteArrayList

## 5.Java的堆和栈有什么不同？

## 6.Java中的活锁、死锁、饥饿有什么区别？

## 7.写一个死锁的程序，如何检测？如何避免？

## 8.什么是线程池？线程池的工作原理和使用线程的好处？

## 9.如何在两个线程间共享数据？

## 10.Collections.syschronizedXXX方法的原理

## 11.ThreadLocal的原理

## 12.如何停止一个线程

## 13.三个线程T1、T2、T3，如何确保它们顺序执行？

## 14.线程的状态？（画图）

## 15.什么是线程调度器？

## 16.用户线程与守护线程有什么区别

## 17.怎么检测一个线程是否拥有锁

## 18.什么是线程的上下文切换？

## 19.Java创建线程后，调用start()和run()的区别？

## 20.Wait()和sleep()的区别？

## 21.Interrupted()方法和isinterrupted方法的区别？

## 22.锁优化？（自旋锁->锁清除->锁粗化->轻量级锁->偏向锁）

## 23.多线程中锁的种类（可重入锁、可中断锁、公平锁、读写锁）

## 24.3条多线程最佳实践

## 25.多线程的优点和缺点

## 26.线程通信？？？

## 27.多线程实现的四种方式？

## 28.Callable与runnable的区别？

## 29.Synchronized与lock的用法？volatile与synchronized 的区别？

## 30.CAS操作？

## 31.wait()\notify()\notifyall()用法(Java中怎样唤醒一个阻塞的线程？)

## 32.写出生产者消费者模式

### 补充1:
 在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被放在堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

### 补充2:
但是使用 += 运算符可以执行隐式类型转换。

### 补充3:
equals() 与 == 的区别:
#### (1). 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
#### (2). 对于引用类型，== 判断两个实例是否引用同一个对象，而 equals() 判断引用的对象是否等价。

#### (4). 存在继承的情况下，初始化顺序为：

父类（静态变量、静态语句块）
子类（静态变量、静态语句块）
父类（实例变量、普通语句块）
父类（构造函数）
子类（实例变量、普通语句块）
子类（构造函数）
